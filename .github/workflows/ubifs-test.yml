name: UBIFS Test

on:
   repository_dispatch:
   workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH connection to Actions'
        required: true
        default: 'false'
        type: choice
        options:
        - "true"
        - "false"
      version:
        description: 'OpenWrt version'
        required: true
        default: 'snapshot'
        type: string

jobs:
  ubifs-workflow:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get current kernel version and fetch source
        id: get_kernel_source
        run: |
          # Get the host runner's kernel version
          export kernel_version=$(uname -r)
          echo "kernel_version=${kernel_version}" >> $GITHUB_OUTPUT
          # Extract Ubuntu series and version from the kernel version
          export ub_series=$(echo "$kernel_version" | sed -E 's/.*-([a-z]+[0-9]+).*/\1/')
          export ub_version=$(echo "$kernel_version" | sed -E 's/.*-([a-z]+[0-9]+).*/linux-\1/')
          
          # Use a standard location for kernel source, e.g., using apt
          # This will install the kernel headers package, which often creates the build symlink
          # Find the main sources list file and uncomment deb-src entries
          if [ -f /etc/apt/sources.list.d/ubuntu.sources ]; then
            sudo sed -Ei 's/^Types: deb$/Types: deb deb-src/' /etc/apt/sources.list.d/ubuntu.sources
          else
            sudo sed -i 's/^# deb-src/deb-src/' /etc/apt/sources.list
          fi

          # Extract kernel type from the version string (e.g., "azure")
          kernel_type=azure
          #$(echo "$kernel_version" | grep -oP '\-\K[a-z]+(?=\-\d)')
          if [[ -z "$kernel_type" ]]; then
            kernel_source_name="linux"
          else
            kernel_source_name="linux-${kernel_type}"
          fi
          echo "Kernel type is $kernel_type "
          # Extract Ubuntu series (e.g., "jammy" for kernel 5.15) from the runner's OS version
                    # Use a lookup table to determine the Ubuntu series based on the major kernel version
          major_kernel_version=$(echo "$kernel_version" | cut -d'.' -f1)
          case "$major_kernel_version" in
            5) ubuntu_series="jammy";;
            6) ubuntu_series="lunar";;
            # Add more cases as needed for future runner versions
            *) 
               echo "Warning: Could not determine Ubuntu series for kernel $kernel_version. Defaulting to 'jammy'."
               ubuntu_series="jammy";;
          esac
          echo "Kernel series is $ubuntu_series "          
          sudo apt-get update
          sudo apt-get install -y linux-headers-${kernel_version}
          sudo apt-get install -y dpkg-dev
          sudo apt-get install -y git

          # Get kernel source
          cd /tmp
          apt-get source linux-image-${kernel_version} || apt-get source linux-image-unsigned-${kernel_version} || apt-get source linux-image-generic
          
          # Find the extracted kernel source directory
          export KERNEL_SOURCE_DIR=$(find . -maxdepth 1 -type d -name "linux-*" | head -n 1)
          if [ -z "$KERNEL_SOURCE_DIR" ]; then
            echo "Failed to find extracted kernel source directory."
            exit 1
          fi
          
          # Clone the kernel source from Launchpad and checkout the correct branch
          echo "Cloning kernel source for series: ${ubuntu_series} from repo: ${kernel_source_name}..."
          cd /tmp
          #git clone --depth 1 git://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/${kernel_source_name}/+git/${ubuntu_series} kernel_build
          git clone --depth 1 git://git.launchpad.net/ubuntu/+source/linux-signed-azure-6.14 kernel_build
          cd kernel_build

          # Check out the commit matching the host's kernel for best compatibility
          if ! git checkout Ubuntu-"${kernel_version}" 2>/dev/null; then
            echo "Warning: No exact tag match for Ubuntu-${kernel_version}. Using the main branch."
            git fetch origin main || git fetch origin master || git fetch origin applied/ubuntu/devel
            git branch -a
            git checkout main || git checkout master || git checkout ubuntu/devel
          fi
          
          # Switch to the 'master' branch, which contains the kernel source
          #git fetch origin master
          #git checkout master
          
          # Use the commit matching the host's kernel for best compatibility
          #if ! git checkout Ubuntu-"${kernel_version}" 2>/dev/null; then
          #  echo "Warning: No exact tag match for Ubuntu-${kernel_version}. Using master branch."
          #fi 
          
          echo "#################kernel_source_path=/tmp/${KERNEL_SOURCE_DIR}"
          #ls -latR /tmp/kernel_build
          #echo "kernel_source_path=/tmp/${KERNEL_SOURCE_DIR}" >> $GITHUB_OUTPUT
          echo "kernel_source_path=/tmp/kernel_build" >> $GITHUB_OUTPUT




      - name: Run container with privileged access
        # Run the container with the privileged flag
        #run: docker run --privileged -v ${{ github.workspace }}:/workspace ubifs-test-image /workspace/.github/scripts/run-test.sh
        run: |
          
          docker build -t ubifs-builder -f Dockerfile.ubifs .
          echo "################### ${{ steps.get_kernel_source.outputs.kernel_source_path }}"
          ls -latR ${{ steps.get_kernel_source.outputs.kernel_source_path }}
          docker run --privileged \
            -v /lib/modules:/lib/modules \
            -v /usr/src:/usr/src \
            -v ${{ github.workspace }}:/workspace \
            -v /tmp/kernel_build:/usr/src/kernel_build \
            -w /workspace \
            ubifs-builder /bin/bash -c "
            set -e

            # Install kernel headers (from the host, not repo)
            apt-get update && apt-get install -y linux-headers-${{ steps.get_kernel_version.outputs.kernel_version }}

            # Locate or clone the kernel source for nandsim
            # NOTE: If the runner's kernel source isn't on the runner, you'll need to clone it
            # This example assumes the headers package install places the source in a standard location
            # Use the already installed headers/source on the host
            #export KERN_BUILD_DIR=/lib/modules/${{ steps.get_kernel_source.outputs.kernel_version }}/build
            # Use the mounted kernel source
            KERN_BUILD_DIR=/usr/src/kernel_build
            
            #KERN_BUILD_DIR=/lib/modules/${{ steps.get_kernel_version.outputs.kernel_version }}/build
            #if [ ! -d \"$KERN_BUILD_DIR\" ]; then
            #  echo 'Kernel build directory not found. Please provide the kernel source.'
            #  exit 1
            #fi

            # Build and insert nandsim module
            echo 'Building nandsim module...'
            make -C /usr/src/kernel_build  M=\"/workspace/\" modules
            #make -C /usr/src/kernel_build M=drivers/mtd/nand/raw modules
            ls -latR /workspace/
            ls -latR drivers/mtd/nand/raw
            ls -latR /usr/src/kernel_build
            insmod drivers/mtd/nand/raw/nandsim.ko

            # Verify nandsim module is loaded
            if lsmod | grep nandsim; then
              echo 'nandsim module loaded successfully.'
            else
              echo 'Failed to load nandsim module.'
              exit 1
            fi

            # Create a NAND device and UBIFS volume
            modprobe mtdblock
            modprobe ubi
            echo 'Configuring nandsim and UBIFS...'

            # Create the UBIFS image (adjust size and eraseblock size as needed)
            flash_eraseall /dev/mtd0
            mkfs.ubifs -r /dev/mtd0 -m 2048 -e 126976 -c 1024 -o ubifs.img

            # Attach UBI device
            ubiattach /dev/ubi_ctrl -m 0
            ubimkvol /dev/ubi0 -N my_ubifs_volume -m

            # Mount the UBIFS volume
            mkdir -p /mnt/ubifs
            mount -t ubifs ubi0:my_ubifs_volume /mnt/ubifs

            echo 'UBIFS mounted at /mnt/ubifs.'
            ls -l /mnt/ubifs
          "
